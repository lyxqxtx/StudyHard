
subtree命令在git2.34.1上，无法tab补全，官方指南也没有相关描述，只有subModule；但-h是有效的

subtree命令：
	添加：添加子版本树，添加的子版本树仅相当于主版本的一个普通目录，因此不会主动同步到远程子仓库上。使用
		git subtree add --prefix=子仓库目录名 子仓库地址 分支名称 --squash
	      简化操作：可以新增一个远程仓库别名，免得每次都要输一次子仓库地址。使用
	      		git remote add 远程子仓库 别名
	更新；可以在主仓库中更新子仓库，使用
		git subtree pull --prefix=子仓库目录名 子仓库地址 分支名称 --squash
	修改：因为对于主仓库来说，子仓库就是个普通目录，因此直接在主仓库中修改即可。
		如果需要同步到子版本树，使用
			git subtree push --prefix=子版本树名称 子仓库地址
			这只会将主仓库对子仓库的修改更新到远程子仓库。
	移除：因为对于主仓库来说，子仓库就是个普通目录，因此使用
		git rm 子仓库目录
		git commit -m "说明"
	切换子仓库分支：通过移除当前子仓库后，重新添加子仓库的目标分支
		git rm 子仓库目录
		git commit -m "说明"
		git subtree pull --prefix=子仓库目录名 子仓库地址 分支名称 --squash

	特别注意：在主仓库更新子仓库，主仓库会以合并修改的方式更新。也就是说，主仓库会先应用子仓库的更新，然后再合并自身的版本。表现为：
		子仓库的更新不会修改主仓库记录的内容，只会更新主仓库没有记录的内容。但是子仓库总是会被主仓库更新。
	例子1：在主仓库中为子仓库新增了一个文件A，然后提交主仓库代码，再推送到远程子仓库，远程子仓库将会被更新。
	例子2：在例子1之后，远程子仓库发现不需要这个文件A，因此（在另一个工程里）删了，然后推送修改。这时候，主仓库再次更新子仓库，文件A仍然存在，
		并不会“被子仓库删除”。这是因为主仓库仍然存在这个文件A的版本。
	例子3：在例子1之后，主仓库在文件A中输入了字符“ABCD”，然后提交修改，同时还推送到子仓库。这时候，子仓库发现被更新，然后它把这个“ABCD”改成了
		“1234”，然后提交修改。然后主仓库再次更新子仓库，发现冲突。需要手动解决主仓库中“ABCD”版本和子仓库中“1234”版本的冲突。
